#!/usr/bin/env python3
"""
Base Events - Core event system for DroxAI CHIMERA AUTARCH
Demonstrates basic event publishing and monitoring functionality
"""

import asyncio
import random
import time
import logging
from typing import Dict, Any
from event_broker import EventBroker, EventType, Event
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class BaseEventSystem:
    """Base event system implementation for DroxAI"""
    
    def __init__(self):
        self.broker = EventBroker()
        self.running = False
        self.stats = {
            "events_generated": 0,
            "start_time": None,
            "event_types_generated": {}
        }
        
        logger.info("BaseEventSystem initialized")

    async def start(self):
        """Start the base event system"""
        self.running = True
        self.stats["start_time"] = time.time()
        logger.info("BaseEventSystem started")

    async def stop(self):
        """Stop the base event system"""
        self.running = False
        logger.info("BaseEventSystem stopped")

    async def generate_sample_events(self, count: int = 10):
        """Generate sample events for demonstration"""
        logger.info(f"Generating {count} sample events...")
        
        for i in range(count):
            if not self.running:
                break
                
            # Randomly select an event type
            event_type = random.choice(list(EventType))
            
            # Generate event data based on type
            event_data = self._generate_event_data(event_type)
            
            # Create and publish event
            event = Event(
                type=event_type,
                data=event_data,
                priority=random.randint(1, 10)
            )
            
            await self.broker.publish(event)
            self._update_stats(event_type)
            
            # Small delay between events
            await asyncio.sleep(0.1)
            
        logger.info(f"Generated {count} sample events")

    def _generate_event_data(self, event_type: EventType) -> Dict[str, Any]:
        """Generate sample data for different event types"""
        
        if event_type == EventType.EVOLUTION_APPLIED:
            return {
                "topic": f"evolution_topic_{random.randint(1, 100)}",
                "improvement": round(random.uniform(-0.1, 0.5), 4),
                "fix": f"Applied optimization fix #{random.randint(1000, 9999)}"
            }
            
        elif event_type == EventType.NODE_REGISTERED:
            return {
                "node_id": f"node_{random.randint(1000, 9999)}",
                "type": random.choice(["worker", "coordinator", "monitor"]),
                "capabilities": random.sample([
                    "data_processing", "ml_inference", "web_scraping", 
                    "file_analysis", "api_integration"
                ], random.randint(1, 3))
            }
            
        elif event_type == EventType.TOOL_EXECUTED:
            return {
                "tool": random.choice([
                    "file_analyzer", "web_scraper", "data_processor", 
                    "ml_predictor", "api_caller"
                ]),
                "success": random.choice([True, True, True, False]),  # 75% success rate
                "latency": round(random.uniform(0.01, 2.0), 4)
            }
            
        elif event_type == EventType.CONFIDENCE_CHANGED:
            return {
                "topic": f"confidence_topic_{random.randint(1, 50)}",
                "old_confidence": round(random.uniform(0.3, 0.9), 4),
                "new_confidence": round(random.uniform(0.3, 0.95), 4),
                "delta": round(random.uniform(-0.2, 0.2), 4)
            }
            
        elif event_type == EventType.LEARNING_STARTED:
            return {
                "model": f"model_v{random.randint(1, 10)}",
                "dataset_size": random.randint(1000, 100000),
                "learning_rate": round(random.uniform(0.001, 0.1), 6)
            }
            
        elif event_type == EventType.LEARNING_COMPLETED:
            return {
                "model": f"model_v{random.randint(1, 10)}",
                "accuracy": round(random.uniform(0.7, 0.99), 4),
                "training_time": round(random.uniform(10, 3600), 2)
            }
            
        elif event_type == EventType.TASK_DISPATCHED:
            return {
                "task_id": f"task_{random.randint(10000, 99999)}",
                "tool": random.choice([
                    "analyzer", "scraper", "processor", "predictor", "integrator"
                ]),
                "priority": random.randint(1, 10)
            }
            
        elif event_type == EventType.TASK_COMPLETED:
            return {
                "task_id": f"task_{random.randint(10000, 99999)}",
                "success": random.choice([True, True, False]),  # 67% success rate
                "execution_time": round(random.uniform(0.5, 30.0), 2)
            }
            
        elif event_type == EventType.SYSTEM_ALERT:
            return {
                "level": random.choice(["info", "warning", "error"]),
                "message": f"System alert #{random.randint(1, 1000)}: {random.choice([
                    'High CPU usage detected',
                    'Memory threshold exceeded',
                    'Network latency increased',
                    'Disk space running low',
                    'Service restart required'
                ])}",
                "context": {
                    "timestamp": datetime.now().isoformat(),
                    "source": "base_events.py"
                }
            }
            
        else:
            # Generic event data
            return {
                "message": f"Sample event data for {event_type.value}",
                "value": random.randint(1, 100),
                "timestamp": datetime.now().isoformat()
            }

    def _update_stats(self, event_type: EventType):
        """Update internal statistics"""
        self.stats["events_generated"] += 1
        event_name = event_type.value
        
        if event_name not in self.stats["event_types_generated"]:
            self.stats["event_types_generated"][event_name] = 0
            
        self.stats["event_types_generated"][event_name] += 1

    def get_stats(self) -> Dict[str, Any]:
        """Get current system statistics"""
        runtime = 0
        if self.stats["start_time"]:
            runtime = time.time() - self.stats["start_time"]
            
        return {
            **self.stats,
            "runtime_seconds": round(runtime, 2),
            "events_per_second": round(
                self.stats["events_generated"] / max(runtime, 1), 2
            )
        }

    async def run_continuous_demo(self, duration: int = 30):
        """Run continuous event generation demo"""
        logger.info(f"Starting continuous demo for {duration} seconds...")
        
        await self.start()
        start_time = time.time()
        
        try:
            while time.time() - start_time < duration and self.running:
                # Generate burst of events
                await self.generate_sample_events(random.randint(3, 8))
                
                # Wait before next burst
                await asyncio.sleep(random.uniform(1, 3))
                
        except KeyboardInterrupt:
            logger.info("Demo interrupted by user")
        finally:
            await self.stop()
            
        # Print final stats
        stats = self.get_stats()
        logger.info("Demo completed. Final statistics:")
        logger.info(f"Total events generated: {stats['events_generated']}")
        logger.info(f"Runtime: {stats['runtime_seconds']} seconds")
        logger.info(f"Events per second: {stats['events_per_second']}")
        
        # Event type breakdown
        logger.info("Event type breakdown:")
        for event_type, count in stats["event_types_generated"].items():
            logger.info(f"  {event_type}: {count}")


async def demo_basic_events():
    """Basic demonstration of event system"""
    print("Starting Basic Event System Demo...")
    print("=" * 50)
    
    system = BaseEventSystem()
    
    # Generate a few sample events
    await system.generate_sample_events(5)
    
    # Show stats
    stats = system.get_stats()
    print(f"\nEvent Statistics:")
    print(f"Events generated: {stats['events_generated']}")
    print(f"Event types: {list(stats['event_types_generated'].keys())}")
    
    print("\nBasic demo completed!")


async def demo_continuous_events():
    """Continuous event generation demo"""
    print("Starting Continuous Event Generation...")
    print("=" * 50)
    print("Press Ctrl+C to stop early")
    print("-" * 50)
    
    system = BaseEventSystem()
    await system.run_continuous_demo(duration=20)


async def demo_event_broker_features():
    """Demonstrate advanced EventBroker features"""
    print("Testing EventBroker Features...")
    print("=" * 50)
    
    broker = EventBroker()
    
    # Test event history
    print("Testing event history...")
    await broker.emit_evolution("test_topic", 0.1234, "Test optimization")
    await broker.emit_node_event(EventType.NODE_REGISTERED, "test_node_001")
    await broker.emit_alert("info", "Test alert message")
    
    # Get history
    history = broker.get_history(limit=5)
    print(f"Retrieved {len(history)} events from history")
    
    # Get stats
    stats = broker.get_stats()
    print(f"Broker statistics: {stats}")
    
    print("\nEventBroker demo completed!")


def main():
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Base Events - DroxAI Event System Demo"
    )
    parser.add_argument(
        "--mode", 
        choices=["basic", "continuous", "broker", "all"],
        default="basic",
        help="Demo mode to run"
    )
    parser.add_argument(
        "--duration",
        type=int,
        default=20,
        help="Duration for continuous mode (seconds)"
    )
    
    args = parser.parse_args()
    
    print("DroxAI Base Events System")
    print("=" * 50)
    
    if args.mode == "basic":
        asyncio.run(demo_basic_events())
    elif args.mode == "continuous":
        asyncio.run(demo_continuous_events())
    elif args.mode == "broker":
        asyncio.run(demo_event_broker_features())
    elif args.mode == "all":
        print("Running all demos...\n")
        asyncio.run(demo_basic_events())
        print("\n" + "=" * 50 + "\n")
        asyncio.run(demo_event_broker_features())
        print("\n" + "=" * 50 + "\n")
        asyncio.run(demo_continuous_events())


if __name__ == "__main__":
    main()

import http.server
import socketserver
import json
import logging
import threading
from typing import TYPE_CHECKING
from urllib.parse import urlparse, parse_qs

# Import the backend components, using TYPE_CHECKING to prevent circular imports 
# at runtime if they were running in different processes, but useful for typing.
if TYPE_CHECKING:
    from chimera_autarch_v4_tuned import EnhancedHeartNode, ConfigManager

logger = logging.getLogger("chimera.http")

# Thread-local storage for passing the heart instance and config
local_data = threading.local()

class SimpleHTTPRequestHandler(http.server.BaseHTTPRequestHandler):
    """Custom handler for serving JSON API responses and static files."""
    
    def _set_headers(self, status_code=200, content_type='application/json'):
        self.send_response(status_code)
        self.send_header('Content-type', content_type)
        self.end_headers()

    def do_GET(self):
        """Handle GET requests for API endpoints and static content."""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        # Access the heart node instance passed from the server setup
        heart = getattr(local_data, 'heart', None)

        if path == "/health":
            self.do_health_check(heart)
        elif path == "/status":
            self.do_system_status(heart)
        elif path == "/graphql":
            self.do_graphql_query(heart, parsed_path)
        elif path == "/dashboard.html":
            self.do_serve_static("dashboard.html", "text/html")
        else:
            self._set_headers(404)
            self.wfile.write(json.dumps({"error": "Not Found"}).encode('utf-8'))

    def do_health_check(self, heart):
        """Handle /health endpoint (basic readiness check)."""
        if not heart:
            self._set_headers(503)
            response = {"status": "critical", "message": "Backend not initialized"}
        else:
            health = heart.performance_monitor.get_system_health()
            if health.get("health_score", 0.0) < 0.4:
                self._set_headers(503)
            else:
                self._set_headers(200)
            response = {"status": health["status"], "score": f"{health['health_score']:.2f}"}

        self.wfile.write(json.dumps(response).encode('utf-8'))

    def do_system_status(self, heart):
        """Handle /status endpoint (detailed system metrics)."""
        if not heart:
            self._set_headers(503)
            response = {"error": "Backend not initialized"}
        else:
            # Note: This is synchronous, which is generally bad practice in production,
            # but is acceptable for simple monitoring checks in a simple Python HTTP server.
            # A full FastAPI/ASGI implementation would handle this asynchronously.
            status_task = heart.get_system_status()
            loop = asyncio.get_event_loop()
            status = loop.run_until_complete(status_task)
            
            self._set_headers(200)
            response = status

        self.wfile.write(json.dumps(response).encode('utf-8'))

    def do_graphql_query(self, heart, parsed_path):
        """Placeholder for the GraphQL endpoint."""
        query_components = parse_qs(parsed_path.query)
        query = query_components.get('query', [''])[0]

        if not heart:
            self._set_headers(503)
            response = {"error": "Backend not initialized"}
        elif not query:
            self._set_headers(400)
            response = {"error": "Missing 'query' parameter"}
        else:
            # In a real app, this would use graphql_api.py to process the query
            self._set_headers(200)
            response = {
                "data": {
                    "queryStatus": f"GraphQL query received: {query[:30]}...",
                    "note": "GraphQL engine (graphql_api.py) requires full implementation."
                }
            }

        self.wfile.write(json.dumps(response).encode('utf-8'))

    def do_serve_static(self, filename, content_type):
        """Attempts to serve a static file from the current directory."""
        try:
            with open(filename, 'rb') as f:
                content = f.read()
            self._set_headers(200, content_type)
            self.wfile.write(content)
        except FileNotFoundError:
            self._set_headers(404)
            self.wfile.write(json.dumps({"error": f"File {filename} not found."}).encode('utf-8'))

class ThreadedHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):
    """Handle requests in a separate thread."""
    pass

def run_http_server(heart_node, config):
    """Starts the HTTP server in a separate thread."""
    global local_data
    
    # Use thread-local storage to pass the heart instance to the handler
    local_data.heart = heart_node
    
    # Use config values for binding
    HTTP_HOST = config.server.http_host
    HTTP_PORT = config.server.http_port

    try:
        httpd = ThreadedHTTPServer((HTTP_HOST, HTTP_PORT), SimpleHTTPRequestHandler)
        logger.info(f"[HTTP] Serving at http://{HTTP_HOST}:{HTTP_PORT}")
        httpd.serve_forever()
    except Exception as e:
        logger.error(f"[HTTP] Failed to start HTTP Server: {e}")
        # Signal shutdown if server fails to start
        return 1
    finally:
        logger.info("[HTTP] HTTP server shut down.")
        
# --------------------------------------------------------------------------- #
# Integration: Update chimera_autarch_v4_tuned.py to launch this server
# --------------------------------------------------------------------------- #
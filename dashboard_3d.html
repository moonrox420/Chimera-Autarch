<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drox_AI 3D Evolution Dashboard</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #dashboard-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            z-index: 100;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #00ffff;
            font-size: 16px;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .control-group button {
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            border: none;
            color: #000;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .control-group button:hover {
            transform: scale(1.05);
        }
        
        #stats-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }
        
        .stat-value {
            color: #00ff00;
            font-weight: bold;
        }
        
        #evolution-timeline {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ffff00;
            border-radius: 10px;
            padding: 15px;
        }
        
        .timeline-item {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 255, 0, 0.1);
            border-radius: 3px;
            font-size: 12px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="loading">üöÄ Initializing Drox_AI 3D Dashboard...</div>
    
    <div id="dashboard-container" style="display: none;">
        <div id="canvas-container"></div>
        
        <div id="control-panel">
            <h2 style="color: #00ffff; margin-top: 0;">üß¨ Evolution Controls</h2>
            
            <div class="control-group">
                <h3>üéÆ Camera Controls</h3>
                <button onclick="cameraOrbit()">üîÑ Auto Orbit</button>
                <button onclick="resetCamera()">üè† Reset View</button>
                <button onclick="toggleWireframe()">üî≥ Wireframe</button>
            </div>
            
            <div class="control-group">
                <h3>‚ö° Evolution Speed</h3>
                <input type="range" id="speedSlider" min="0.1" max="5" value="1" step="0.1">
                <div style="font-size: 12px; color: #888;">Speed: <span id="speedValue">1.0x</span></div>
            </div>
            
            <div class="control-group">
                <h3>üé® Display Mode</h3>
                <button onclick="showPopulation()">üë• Population</button>
                <button onclick="showEvolution()">üìà Evolution Path</button>
                <button onclick="showFitness()">üéØ Fitness Cloud</button>
            </div>
            
            <div class="control-group">
                <h3>ü§ñ AI Actions</h3>
                <button onclick="startEvolution()">‚ñ∂Ô∏è Start Evolution</button>
                <button onclick="pauseEvolution()">‚è∏Ô∏è Pause</button>
                <button onclick="resetEvolution()">üîÑ Reset</button>
            </div>
        </div>
        
        <div id="stats-panel">
            <h3 style="color: #00ff00; margin-top: 0;">üìä System Stats</h3>
            <div class="stat-item">
                <span>Generation:</span>
                <span class="stat-value" id="generation">0</span>
            </div>
            <div class="stat-item">
                <span>Population:</span>
                <span class="stat-value" id="population">0</span>
            </div>
            <div class="stat-item">
                <span>Best Fitness:</span>
                <span class="stat-value" id="bestFitness">0.000</span>
            </div>
            <div class="stat-item">
                <span>Avg Fitness:</span>
                <span class="stat-value" id="avgFitness">0.000</span>
            </div>
            <div class="stat-item">
                <span>Diversity:</span>
                <span class="stat-value" id="diversity">0.000</span>
            </div>
            <div class="stat-item">
                <span>Mutations:</span>
                <span class="stat-value" id="mutations">0</span>
            </div>
        </div>
        
        <div id="evolution-timeline">
            <h3 style="color: #ffff00; margin-top: 0;">üïí Evolution Timeline</h3>
            <div id="timeline-content"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let population = [];
        let evolutionData = [];
        let currentGeneration = 0;
        let isAnimating = false;
        let animationSpeed = 1.0;
        let autoOrbit = false;
        let displayMode = 'population';

        // Initialize the 3D dashboard
        function init() {
            try {
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                document.getElementById('dashboard-container').style.display = 'block';
                
                // Setup Three.js scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000510);
                
                // Setup camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 10, 20);
                
                // Setup renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(renderer.domElement);
                
                // Add controls
                setupControls();
                
                // Setup lighting
                setupLighting();
                
                // Create initial population
                generatePopulation();
                
                // Start render loop
                animate();
                
                // Setup event listeners
                setupEventListeners();
                
                console.log('‚úÖ Drox_AI 3D Dashboard initialized successfully!');
                
            } catch (error) {
                console.error('‚ùå Dashboard initialization failed:', error);
                document.getElementById('loading').innerHTML = '‚ùå Failed to initialize dashboard';
            }
        }

        function setupControls() {
            // Mouse controls (basic)
            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                camera.position.x += deltaX * 0.01;
                camera.position.y -= deltaY * 0.01;
                camera.lookAt(0, 0, 0);
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            // Scroll to zoom
            renderer.domElement.addEventListener('wheel', (event) => {
                camera.position.z += event.deltaY * 0.01;
                camera.position.z = Math.max(5, Math.min(50, camera.position.z));
            });
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0x00ffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Point lights for effect
            const pointLight1 = new THREE.PointLight(0xff00ff, 0.5, 30);
            pointLight1.position.set(-10, 5, 10);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x00ff00, 0.5, 30);
            pointLight2.position.set(10, -5, -10);
            scene.add(pointLight2);
        }

        function generatePopulation() {
            // Clear existing population
            population.forEach(individual => scene.remove(individual.mesh));
            population = [];
            
            // Create 20 individuals in a spiral pattern
            const numIndividuals = 20;
            for (let i = 0; i < numIndividuals; i++) {
                const fitness = Math.random();
                const individual = createIndividual(fitness, i);
                population.push(individual);
                scene.add(individual.mesh);
            }
            
            // Generate evolution data
            generateEvolutionData();
            updateStats();
        }

        function createIndividual(fitness, index) {
            const geometry = new THREE.SphereGeometry(0.3 + fitness * 0.2, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(fitness / 3, 1, 0.5),
                transparent: true,
                opacity: 0.8
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // Position in spiral pattern
            const angle = (index / numIndividuals) * Math.PI * 4;
            const radius = 5 + fitness * 3;
            mesh.position.x = Math.cos(angle) * radius;
            mesh.position.y = (fitness - 0.5) * 8;
            mesh.position.z = Math.sin(angle) * radius;
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(0.5 + fitness * 0.3, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(fitness / 3, 1, 0.5),
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            mesh.add(glow);
            
            return {
                mesh: mesh,
                fitness: fitness,
                generation: 0,
                genes: generateRandomGenes()
            };
        }

        function generateRandomGenes() {
            return {
                learning_rate: Math.random() * 0.1,
                confidence: Math.random(),
                adaptability: Math.random(),
                batch_size: Math.floor(Math.random() * 3) + 16,
                latency_tolerance: Math.random() * 150 + 50
            };
        }

        function generateEvolutionData() {
            evolutionData = [];
            let currentBestFitness = 0;
            
            for (let gen = 0; gen < 10; gen++) {
                // Simulate fitness improvement
                const improvement = Math.random() * 0.3;
                currentBestFitness += improvement * (1 - currentBestFitness);
                
                evolutionData.push({
                    generation: gen,
                    bestFitness: currentBestFitness,
                    avgFitness: currentBestFitness * (0.8 + Math.random() * 0.4),
                    mutations: Math.floor(Math.random() * 5) + 1,
                    diversity: Math.random() * 0.5 + 0.3
                });
            }
        }

        function updatePopulation() {
            if (!isAnimating) return;
            
            currentGeneration = Math.min(currentGeneration + 0.1 * animationSpeed, evolutionData.length - 1);
            
            if (currentGeneration >= evolutionData.length - 1) {
                currentGeneration = 0; // Loop
            }
            
            const data = evolutionData[Math.floor(currentGeneration)];
            
            // Update individual positions and colors
            population.forEach((individual, index) => {
                const progress = (currentGeneration + index * 0.1) % 1;
                individual.fitness = data.bestFitness * (0.7 + Math.random() * 0.3);
                
                // Update appearance
                const hue = individual.fitness / 3;
                individual.mesh.material.color.setHSL(hue, 1, 0.5);
                individual.mesh.scale.setScalar(1 + individual.fitness * 0.5);
                
                // Gentle floating animation
                individual.mesh.position.y += Math.sin(Date.now() * 0.001 + index) * 0.01;
            });
            
            updateStats();
            
            if (displayMode === 'evolution') {
                updateEvolutionPath();
            }
        }

        function updateEvolutionPath() {
            // Remove old path
            const oldPath = scene.getObjectByName('evolutionPath');
            if (oldPath) scene.remove(oldPath);
            
            // Create new path
            const points = [];
            for (let i = 0; i <= currentGeneration; i++) {
                if (evolutionData[i]) {
                    points.push(new THREE.Vector3(
                        (i - 5) * 2,
                        evolutionData[i].bestFitness * 10,
                        0
                    ));
                }
            }
            
            if (points.length > 1) {
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
                const path = new THREE.Line(geometry, material);
                path.name = 'evolutionPath';
                scene.add(path);
            }
        }

        function updateStats() {
            const data = evolutionData[Math.floor(currentGeneration)] || evolutionData[0];
            
            document.getElementById('generation').textContent = Math.floor(currentGeneration);
            document.getElementById('population').textContent = population.length;
            document.getElementById('bestFitness').textContent = data.bestFitness.toFixed(3);
            document.getElementById('avgFitness').textContent = data.avgFitness.toFixed(3);
            document.getElementById('diversity').textContent = data.diversity.toFixed(3);
            document.getElementById('mutations').textContent = data.mutations;
            
            updateTimeline();
        }

        function updateTimeline() {
            const timeline = document.getElementById('timeline-content');
            timeline.innerHTML = '';
            
            const startGen = Math.max(0, Math.floor(currentGeneration) - 3);
            const endGen = Math.min(evolutionData.length - 1, startGen + 6);
            
            for (let i = startGen; i <= endGen; i++) {
                const data = evolutionData[i];
                const div = document.createElement('div');
                div.className = 'timeline-item';
                div.innerHTML = `
                    Gen ${i}: Fitness ${data.bestFitness.toFixed(3)}
                    <div style="font-size: 10px; color: #888;">
                        Mutations: ${data.mutations}, Diversity: ${data.diversity.toFixed(2)}
                    </div>
                `;
                if (i === Math.floor(currentGeneration)) {
                    div.style.background = 'rgba(255, 255, 0, 0.3)';
                }
                timeline.appendChild(div);
            }
        }

        // Control functions
        function startEvolution() {
            isAnimating = true;
            console.log('‚ñ∂Ô∏è Starting evolution animation');
        }

        function pauseEvolution() {
            isAnimating = false;
            console.log('‚è∏Ô∏è Pausing evolution');
        }

        function resetEvolution() {
            currentGeneration = 0;
            isAnimating = false;
            generatePopulation();
            console.log('üîÑ Evolution reset');
        }

        function cameraOrbit() {
            autoOrbit = !autoOrbit;
            console.log(autoOrbit ? 'üîÑ Auto orbit enabled' : 'üîÑ Auto orbit disabled');
        }

        function resetCamera() {
            camera.position.set(0, 10, 20);
            camera.lookAt(0, 0, 0);
            console.log('üè† Camera reset');
        }

        function toggleWireframe() {
            population.forEach(individual => {
                individual.mesh.material.wireframe = !individual.mesh.material.wireframe;
            });
            console.log('üî≥ Wireframe toggled');
        }

        function showPopulation() {
            displayMode = 'population';
            console.log('üë• Showing population view');
        }

        function showEvolution() {
            displayMode = 'evolution';
            console.log('üìà Showing evolution path');
        }

        function showFitness() {
            displayMode = 'fitness';
            console.log('üéØ Showing fitness cloud');
        }

        // Event listeners
        function setupEventListeners() {
            // Speed slider
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'Space':
                        e.preventDefault();
                        if (isAnimating) pauseEvolution();
                        else startEvolution();
                        break;
                    case 'KeyR':
                        resetEvolution();
                        break;
                    case 'KeyC':
                        resetCamera();
                        break;
                }
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoOrbit) {
                camera.position.x = Math.cos(Date.now() * 0.0005) * 20;
                camera.position.z = Math.sin(Date.now() * 0.0005) * 20;
                camera.lookAt(0, 0, 0);
            }
            
            updatePopulation();
            
            // Rotate individual meshes
            population.forEach((individual, index) => {
                individual.mesh.rotation.y += 0.01;
                individual.mesh.rotation.x += 0.005;
            });
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
